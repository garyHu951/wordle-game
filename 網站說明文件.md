# 🎮 Wordle+ 像素版遊戲 - 網站說明文件

## 📖 創作動機

### 靈感來源
本專案靈感來自於風靡全球的 Wordle 遊戲，但我希望創造一個更具特色和互動性的版本。原版 Wordle 雖然簡潔優雅，但缺乏多人互動和視覺豐富度，因此我決定開發一個結合復古像素風格和現代 Web 技術的增強版本。

### 設計理念
1. **復古美學**：採用像素風格設計，喚起經典遊戲的懷舊感
2. **社交互動**：加入即時多人對戰功能，增強遊戲的競技性
3. **沉浸體驗**：整合音效系統和流暢動畫，提升使用者體驗
4. **技術展示**：運用現代 Web 技術棧，展現全端開發能力

### 目標用戶
- 喜愛文字遊戲的玩家
- 追求復古遊戲體驗的用戶
- 希望與朋友進行即時對戰的社交玩家
- 對現代 Web 技術感興趣的開發者

---

## 🏗️ 網站架構 (頁面結構)

### 前端頁面架構
```
Wordle+ 應用程式
├── 主頁面 (HomePage)
│   ├── 遊戲模式選擇
│   │   ├── 單人模式按鈕
│   │   ├── 對戰模式按鈕
│   │   └── 單字庫按鈕
│   ├── 音效控制面板
│   └── 版本資訊顯示
│
├── 單人遊戲頁面 (SinglePlayerGame)
│   ├── 遊戲控制區
│   │   ├── 單字長度選擇 (4-7字母)
│   │   ├── 新遊戲按鈕
│   │   └── 返回按鈕
│   ├── 遊戲區域
│   │   ├── 猜測網格 (6行 x N列)
│   │   ├── 輸入框
│   │   └── 提交按鈕
│   ├── 狀態顯示
│   │   ├── 剩餘猜測次數
│   │   ├── 遊戲訊息
│   │   └── 字母狀態追蹤器
│   └── 結果彈窗 (勝利/失敗)
│
├── 對戰模式頁面 (CompetitiveMode)
│   ├── 大廳頁面
│   │   ├── 創建房間
│   │   ├── 加入房間
│   │   └── 返回按鈕
│   ├── 等待頁面
│   │   ├── 房間代碼顯示
│   │   ├── 玩家列表
│   │   └── 離開房間按鈕
│   ├── 遊戲頁面
│   │   ├── 雙人遊戲區域
│   │   ├── 分數顯示
│   │   ├── 回合資訊
│   │   └── 跳過按鈕
│   └── 遊戲結束頁面
│       ├── 最終分數
│       ├── 勝負結果
│       └── 返回大廳按鈕
│
└── 單字庫側邊欄 (WordListSidebar)
    ├── 字母長度選擇
    ├── 單字列表 (按字母分組)
    └── 統計資訊
```

### 後端 API 架構
```
後端服務器
├── RESTful API 端點
│   ├── /api/health - 健康檢查
│   ├── /api/words/:length - 單字庫查詢
│   ├── /api/game/new - 創建新遊戲
│   └── /api/game/:id/guess - 提交猜測
│
├── Socket.IO 即時通訊
│   ├── create_room - 創建房間
│   ├── join_room - 加入房間
│   ├── submit_guess_competitive - 對戰猜測
│   ├── skip_round - 跳過回合
│   └── leave_room - 離開房間
│
└── 資料管理
    ├── 單字庫載入 (JSON 檔案)
    ├── 遊戲狀態管理 (內存)
    └── 房間管理 (內存)
```

---

## 💻 實際使用之 Web 技術

### 前端技術棧
1. **React 18**
   - 函數式組件與 Hooks
   - useState, useEffect, useRef 狀態管理
   - 組件化開發架構

2. **Vite**
   - 快速開發伺服器
   - 熱模組替換 (HMR)
   - 優化的生產構建

3. **Tailwind CSS**
   - 實用優先的 CSS 框架
   - 響應式設計
   - 自定義像素風格類別

4. **Socket.IO Client**
   - 即時雙向通訊
   - 自動重連機制
   - 事件驅動架構

5. **Lucide React**
   - 現代 SVG 圖標庫
   - 輕量級且可自定義

### 後端技術棧
1. **Node.js**
   - 非同步 I/O 處理
   - 事件驅動架構
   - 高效能 JavaScript 運行環境

2. **Express.js**
   - RESTful API 框架
   - 中間件支援
   - 路由管理

3. **Socket.IO**
   - 即時通訊協議
   - 房間管理
   - 廣播機制

4. **Mongoose**
   - MongoDB 物件文檔映射
   - 資料驗證
   - 查詢建構器

### 部署技術
1. **GitHub Pages**
   - 靜態網站託管
   - 自動 CI/CD 部署
   - 自定義域名支援

2. **Render**
   - 雲端應用託管
   - 自動擴展
   - 環境變數管理

3. **GitHub Actions**
   - 持續整合/部署
   - 自動化工作流程
   - 多環境支援

---

## 🌟 網站特色與優點

### 1. 視覺設計特色
- **復古像素風格**：完整的像素藝術設計語言
- **流暢動畫效果**：CSS 關鍵幀動畫，提升互動體驗
- **自定義游標**：像素風格滑鼠游標，增強沉浸感
- **響應式佈局**：適配各種螢幕尺寸

### 2. 音效系統優勢
- **分層音效設計**：背景音樂 + 互動音效
- **智能音效管理**：優先級系統，避免音效衝突
- **用戶控制**：音量調節和靜音功能
- **情境音樂**：不同頁面播放對應背景音樂

### 3. 遊戲功能創新
- **多字母長度支援**：4-7字母單字，增加遊戲變化
- **即時多人對戰**：WebSocket 實現的即時競技
- **智能字母追蹤**：視覺化顯示字母使用狀態
- **完整單字庫**：94,974個英文單字，內容豐富

### 4. 技術架構優勢
- **前後端分離**：清晰的架構邊界，易於維護
- **即時通訊**：Socket.IO 提供穩定的即時互動
- **狀態管理**：React Hooks 實現高效狀態管理
- **錯誤處理**：完善的錯誤捕獲和用戶反饋

---

## 🔧 核心程式功能詳解

### 1. 音效管理系統 (AudioManager)

**核心概念**：單例模式的音效管理器，統一處理所有音效播放

```javascript
class AudioManager {
  constructor() {
    this.sounds = {};           // 音效檔案快取
    this.isMuted = false;       // 靜音狀態
    this.volume = 0.7;          // 主音量
    this.currentBgMusic = null; // 當前背景音樂
  }
  
  // 預載入所有音效檔案，避免播放時的延遲
  preloadSounds() {
    Object.entries(this.soundFiles).forEach(([key, path]) => {
      const audio = new Audio(path);
      audio.preload = 'auto';
      this.sounds[key] = audio;
    });
  }
  
  // 播放音效，支援音量控制和錯誤處理
  play(soundName, options = {}) {
    if (this.isMuted) return;
    const sound = this.sounds[soundName];
    sound.currentTime = 0; // 重置播放位置
    sound.volume = options.volume || this.volume;
    sound.play().catch(error => console.warn('播放失敗:', error));
  }
}
```

**技術重點**：
- 使用 HTML5 Audio API 進行音效控制
- 實現音效預載入機制，提升用戶體驗
- 錯誤處理機制，防止音效播放失敗影響遊戲

### 2. 遊戲邏輯核心 (checkGuess 函數)

**核心概念**：實現 Wordle 遊戲的核心邏輯，判斷每個字母的狀態

```javascript
function checkGuess(guess, answer) {
  const result = [];
  const answerArray = answer.split('');
  const guessArray = guess.split('');
  const used = new Array(answer.length).fill(false);
  
  // 第一輪：標記完全正確的字母 (綠色)
  guessArray.forEach((letter, i) => {
    if (letter === answerArray[i]) {
      result[i] = 'correct';
      used[i] = true;
    }
  });
  
  // 第二輪：標記存在但位置錯誤的字母 (黃色)
  guessArray.forEach((letter, i) => {
    if (result[i]) return; // 跳過已標記的
    const foundIndex = answerArray.findIndex((l, idx) => 
      l === letter && !used[idx]
    );
    if (foundIndex !== -1) {
      result[i] = 'present';
      used[foundIndex] = true;
    } else {
      result[i] = 'absent'; // 不存在 (灰色)
    }
  });
  
  return result;
}
```

**演算法分析**：
- **時間複雜度**：O(n²)，其中 n 是單字長度
- **空間複雜度**：O(n)，用於存儲結果和標記陣列
- **邏輯正確性**：兩輪掃描確保字母狀態判斷的準確性

### 3. Socket.IO 即時通訊系統

**核心概念**：基於事件驅動的即時通訊，實現多人對戰功能

```javascript
// 後端房間管理
io.on('connection', (socket) => {
  // 創建房間
  socket.on('create_room', ({ wordLength }) => {
    const roomCode = generateRoomCode(); // 生成6位房間代碼
    rooms[roomCode] = {
      id: roomCode,
      wordLength: parseInt(wordLength),
      players: {},
      currentWords: {}, // 每個玩家的專屬單字
      status: 'waiting'
    };
    
    rooms[roomCode].players[socket.id] = { 
      id: socket.id, 
      score: 0, 
      name: 'Player 1' 
    };
    socket.join(roomCode);
    socket.emit('room_created', { roomCode });
  });
  
  // 處理對戰猜測
  socket.on('submit_guess_competitive', ({ roomCode, guess }) => {
    const room = rooms[roomCode];
    const playerWord = room.currentWords[socket.id];
    const result = checkGuess(guess.toUpperCase(), playerWord);
    const isCorrect = guess.toUpperCase() === playerWord;
    
    if (isCorrect) {
      room.players[socket.id].score += 5;
      // 廣播勝利訊息給所有房間成員
      io.to(roomCode).emit('round_winner', {
        winnerId: socket.id,
        word: playerWord,
        points: 5,
        updatedPlayers: room.players
      });
    }
  });
});
```

**技術重點**：
- **房間隔離**：使用 Socket.IO 的 room 功能實現玩家隔離
- **狀態同步**：即時廣播遊戲狀態變化給所有相關玩家
- **錯誤處理**：連接斷開時的清理機制

### 4. React 狀態管理系統

**核心概念**：使用 React Hooks 實現複雜的遊戲狀態管理

```javascript
const SinglePlayerGame = ({ onBack }) => {
  // 遊戲核心狀態
  const [gameId, setGameId] = useState(null);
  const [guesses, setGuesses] = useState([]);
  const [currentGuess, setCurrentGuess] = useState('');
  const [gameOver, setGameOver] = useState(false);
  const [won, setWon] = useState(false);
  
  // 處理猜測提交
  const handleSubmitGuess = async () => {
    if (currentGuess.length !== wordLength) return;
    
    setLoading(true);
    try {
      const response = await fetch(`${API_URL}/game/${gameId}/guess`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ guess: currentGuess })
      });
      
      const data = await response.json();
      if (data.success) {
        setGuesses(data.guesses);
        setGameOver(data.gameOver);
        setWon(data.won);
        setCurrentGuess('');
        
        // 播放對應的音效
        playResultSounds(data.result);
      }
    } catch (error) {
      console.error('提交猜測失敗:', error);
    }
    setLoading(false);
  };
};
```

**狀態管理策略**：
- **單一資料流**：狀態由上而下傳遞，事件由下而上冒泡
- **副作用管理**：使用 useEffect 處理 API 呼叫和音效播放
- **效能優化**：避免不必要的重新渲染

### 5. 字母狀態追蹤系統

**核心概念**：分析所有猜測記錄，統計每個字母的使用狀態

```javascript
const LetterStatusTracker = ({ guesses }) => {
  const getLetterStatus = () => {
    const correct = new Set();   // 正確位置的字母
    const present = new Set();   // 存在但位置錯誤的字母
    const absent = new Set();    // 不存在的字母

    guesses.forEach(guess => {
      guess.word.split('').forEach((letter, i) => {
        if (guess.result[i] === 'correct') {
          correct.add(letter);
          present.delete(letter); // 從 present 中移除
        } else if (guess.result[i] === 'present' && !correct.has(letter)) {
          present.add(letter);
        } else if (guess.result[i] === 'absent' && 
                   !correct.has(letter) && 
                   !present.has(letter)) {
          absent.add(letter);
        }
      });
    });

    return { 
      correct: Array.from(correct), 
      present: Array.from(present), 
      absent: Array.from(absent) 
    };
  };
```

**演算法優勢**：
- **優先級處理**：正確 > 存在 > 不存在的優先級邏輯
- **集合運算**：使用 Set 資料結構避免重複
- **即時更新**：每次猜測後自動重新計算

### 6. 動畫系統實現

**核心概念**：CSS 關鍵幀動畫配合 JavaScript 類別控制

```css
/* 像素風格動畫定義 */
@keyframes strongImpactBounce {
  0% { transform: scale(1); }
  25% { transform: scale(1.3); }
  50% { transform: scale(1.1); }
  75% { transform: scale(1.2); }
  100% { transform: scale(1); }
}

@keyframes mediumImpactShake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-4px); }
  50% { transform: translateX(4px); }
  75% { transform: translateX(-2px); }
}
```

```javascript
// 動畫觸發邏輯
const playResultSounds = (result) => {
  result.forEach((status, index) => {
    setTimeout(() => {
      const cell = document.querySelector(`[data-cell="${index}"]`);
      
      // 根據結果添加對應動畫類別
      if (status === 'correct') {
        cell.classList.add('animate-strong-impact');
        playSound('correctCell');
      } else if (status === 'present') {
        cell.classList.add('animate-medium-impact');
        playSound('presentCell');
      } else {
        cell.classList.add('animate-weak-impact');
        playSound('absentCell');
      }
      
      // 動畫結束後移除類別
      setTimeout(() => {
        cell.classList.remove('animate-strong-impact', 
                            'animate-medium-impact', 
                            'animate-weak-impact');
      }, 600);
    }, index * 100); // 依序播放動畫
  });
};
```

**技術特點**：
- **步進動畫**：使用 `steps()` 函數實現像素風格的跳躍動畫
- **時序控制**：JavaScript 控制動畫觸發時機和順序
- **性能優化**：動畫結束後自動清理 CSS 類別

---

## 📊 技術成果總結

### 程式碼統計
- **前端代碼**：約 2,200 行 (React + CSS)
- **後端代碼**：約 500 行 (Node.js + Express)
- **配置文件**：約 100 行 (Vite, GitHub Actions)
- **文檔說明**：約 1,000 行 (Markdown)

### 功能完整度
- ✅ **單人遊戲模式**：完整實現
- ✅ **多人對戰模式**：即時通訊正常
- ✅ **音效系統**：全功能支援
- ✅ **視覺動畫**：像素風格完整
- ✅ **響應式設計**：多設備適配
- ✅ **部署自動化**：CI/CD 流程完善

### 技術深度展示
本專案展現了對現代 Web 開發技術棧的深度理解，包括：
- React 生態系統的熟練運用
- Node.js 後端服務開發
- 即時通訊協議實現
- 前後端分離架構設計
- 雲端部署和 DevOps 實踐

這不僅是一個遊戲作品，更是一個完整的全端 Web 應用程式，展現了從需求分析、架構設計、程式實現到部署維護的完整開發流程。